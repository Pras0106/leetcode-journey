# cpp

## Sweet Spot

```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        // Time Complexity: O(n^3)
        // Memory Complexity: O(log n) to O(n) for sorting
        vector<vector<int>> result;
        int n = nums.size();
        if (n < 4) return result;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < n - 3; ++i) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            if ((long)nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) break;
            if ((long)nums[i] + nums[n - 3] + nums[n - 2] + nums[n - 1] < target) continue;
            for (int j = i + 1; j < n - 2; ++j) {
                if (j > i + 1 && nums[j] == nums[j - 1]) continue;
                if ((long)nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) break;
                if ((long)nums[i] + nums[j] + nums[n - 2] + nums[n - 1] < target) continue;
                int left = j + 1, right = n - 1;
                while (left < right) {
                    long sum = (long)nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum == target) {
                        result.push_back({nums[i], nums[j], nums[left], nums[right]});
                        while (left < right && nums[left] == nums[left + 1]) left++;
                        while (left < right && nums[right] == nums[right - 1]) right--;
                        left++;
                        right--;
                    } else if (sum < target) {
                        left++;
                    } else {
                        right--;
                    }
                }
            }
        }
        return result;
    }
};

```

# java

## Sweet Spot

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        // Time Complexity: O(n^3)
        // Memory Complexity: O(log n)
        List<List<Integer>> result = new ArrayList<>();
        int n = nums.length;
        if (n < 4) return result;
        Arrays.sort(nums);
        for (int i = 0; i < n - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) break;
            if ((long) nums[i] + nums[n - 3] + nums[n - 2] + nums[n - 1] < target) continue;
            for (int j = i + 1; j < n - 2; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) continue;
                if ((long) nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) break;
                if ((long) nums[i] + nums[j] + nums[n - 2] + nums[n - 1] < target) continue;
                int left = j + 1, right = n - 1;
                while (left < right) {
                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum == target) {
                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));
                        while (left < right && nums[left] == nums[left + 1]) left++;
                        while (left < right && nums[right] == nums[right - 1]) right--;
                        left++;
                        right--;
                    } else if (sum < target) {
                        left++;
                    } else {
                        right--;
                    }
                }
            }
        }
        return result;
    }
}

```

# python 3.14

## Sweet Spot

```python 3.14
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        # Time Complexity: O(n^3)
        # Memory Complexity: O(n)
        nums.sort()
        n = len(nums)
        res = []
        for i in range(n - 3):
            if i > 0 and nums[i] == nums[i - 1]: continue
            if nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target: break
            if nums[i] + nums[n - 3] + nums[n - 2] + nums[n - 1] < target: continue
            for j in range(i + 1, n - 2):
                if j > i + 1 and nums[j] == nums[j - 1]: continue
                if nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target: break
                if nums[i] + nums[j] + nums[n - 2] + nums[n - 1] < target: continue
                l, r = j + 1, n - 1
                while l < r:
                    s = nums[i] + nums[j] + nums[l] + nums[r]
                    if s == target:
                        res.append([nums[i], nums[j], nums[l], nums[r]])
                        while l < r and nums[l] == nums[l + 1]: l += 1
                        while l < r and nums[r] == nums[r - 1]: r -= 1
                        l += 1
                        r -= 1
                    elif s < target:
                        l += 1
                    else:
                        r -= 1
        return res

```

# python 2.7.11

## Sweet Spot

```python 2.7.11
class Solution(object):
    def fourSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        # Time Complexity: O(n^3)
        # Memory Complexity: O(n)
        nums.sort()
        n = len(nums)
        res = []
        for i in range(n - 3):
            if i > 0 and nums[i] == nums[i - 1]: continue
            if nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target: break
            if nums[i] + nums[n - 3] + nums[n - 2] + nums[n - 1] < target: continue
            for j in range(i + 1, n - 2):
                if j > i + 1 and nums[j] == nums[j - 1]: continue
                if nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target: break
                if nums[i] + nums[j] + nums[n - 2] + nums[n - 1] < target: continue
                l, r = j + 1, n - 1
                while l < r:
                    s = nums[i] + nums[j] + nums[l] + nums[r]
                    if s == target:
                        res.append([nums[i], nums[j], nums[l], nums[r]])
                        while l < r and nums[l] == nums[l + 1]: l += 1
                        while l < r and nums[r] == nums[r - 1]: r -= 1
                        l += 1
                        r -= 1
                    elif s < target:
                        l += 1
                    else:
                        r -= 1
        return res

```

# JavaScript

## Sweet Spot

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
var fourSum = function(nums, target) {
    // Time Complexity: O(n^3)
    // Memory Complexity: O(n)
    const result = [];
    const n = nums.length;
    if (n < 4) return result;
    nums.sort((a, b) => a - b);
    for (let i = 0; i < n - 3; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) continue;
        if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) break;
        if (nums[i] + nums[n - 3] + nums[n - 2] + nums[n - 1] < target) continue;
        for (let j = i + 1; j < n - 2; j++) {
            if (j > i + 1 && nums[j] === nums[j - 1]) continue;
            if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) break;
            if (nums[i] + nums[j] + nums[n - 2] + nums[n - 1] < target) continue;
            let l = j + 1, r = n - 1;
            while (l < r) {
                const sum = nums[i] + nums[j] + nums[l] + nums[r];
                if (sum === target) {
                    result.push([nums[i], nums[j], nums[l], nums[r]]);
                    while (l < r && nums[l] === nums[l + 1]) l++;
                    while (l < r && nums[r] === nums[r - 1]) r--;
                    l++;
                    r--;
                } else if (sum < target) {
                    l++;
                } else {
                    r--;
                }
            }
        }
    }
    return result;
};

```

# Typescript

## Sweet Spot

```typescript
function fourSum(nums: number[], target: number): number[][] {
    // Time Complexity: O(n^3)
    // Memory Complexity: O(n)
    const result: number[][] = [];
    const n = nums.length;
    if (n < 4) return result;
    nums.sort((a, b) => a - b);
    for (let i = 0; i < n - 3; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) continue;
        if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) break;
        if (nums[i] + nums[n - 3] + nums[n - 2] + nums[n - 1] < target) continue;
        for (let j = i + 1; j < n - 2; j++) {
            if (j > i + 1 && nums[j] === nums[j - 1]) continue;
            if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) break;
            if (nums[i] + nums[j] + nums[n - 2] + nums[n - 1] < target) continue;
            let l = j + 1, r = n - 1;
            while (l < r) {
                const sum = nums[i] + nums[j] + nums[l] + nums[r];
                if (sum === target) {
                    result.push([nums[i], nums[j], nums[l], nums[r]]);
                    while (l < r && nums[l] === nums[l + 1]) l++;
                    while (l < r && nums[r] === nums[r - 1]) r--;
                    l++;
                    r--;
                } else if (sum < target) {
                    l++;
                } else {
                    r--;
                }
            }
        }
    }
    return result;
};

```

# C#

## Sweet Spot

```c#
public class Solution {
    public IList<IList<int>> FourSum(int[] nums, int target) {
        // Time Complexity: O(n^3)
        // Memory Complexity: O(log n)
        var result = new List<IList<int>>();
        int n = nums.Length;
        if (n < 4) return result;
        Array.Sort(nums);
        for (int i = 0; i < n - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            if ((long)nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) break;
            if ((long)nums[i] + nums[n - 3] + nums[n - 2] + nums[n - 1] < target) continue;
            for (int j = i + 1; j < n - 2; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) continue;
                if ((long)nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) break;
                if ((long)nums[i] + nums[j] + nums[n - 2] + nums[n - 1] < target) continue;
                int l = j + 1, r = n - 1;
                while (l < r) {
                    long sum = (long)nums[i] + nums[j] + nums[l] + nums[r];
                    if (sum == target) {
                        result.Add(new List<int> { nums[i], nums[j], nums[l], nums[r] });
                        while (l < r && nums[l] == nums[l + 1]) l++;
                        while (l < r && nums[r] == nums[r - 1]) r--;
                        l++;
                        r--;
                    } else if (sum < target) {
                        l++;
                    } else {
                        r--;
                    }
                }
            }
        }
        return result;
    }
}

```

# C

## Sweet Spot

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int compare(const void* a, const void* b) {
    return (*(int*)a > *(int*)b) - (*(int*)a < *(int*)b);
}

int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes) {
    // Time Complexity: O(n^3)
    // Memory Complexity: O(n)
    *returnSize = 0;
    if (numsSize < 4) return NULL;
    qsort(nums, numsSize, sizeof(int), compare);
    int capacity = 100;
    int** result = (int**)malloc(capacity * sizeof(int*));
    *returnColumnSizes = (int*)malloc(capacity * sizeof(int));
    for (int i = 0; i < numsSize - 3; i++) {
        if (i > 0 && nums[i] == nums[i - 1]) continue;
        if ((long)nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) break;
        if ((long)nums[i] + nums[numsSize - 3] + nums[numsSize - 2] + nums[numsSize - 1] < target) continue;
        for (int j = i + 1; j < numsSize - 2; j++) {
            if (j > i + 1 && nums[j] == nums[j - 1]) continue;
            if ((long)nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) break;
            if ((long)nums[i] + nums[j] + nums[numsSize - 2] + nums[numsSize - 1] < target) continue;
            int l = j + 1, r = numsSize - 1;
            while (l < r) {
                long sum = (long)nums[i] + nums[j] + nums[l] + nums[r];
                if (sum == target) {
                    if (*returnSize >= capacity) {
                        capacity *= 2;
                        result = (int**)realloc(result, capacity * sizeof(int*));
                        *returnColumnSizes = (int*)realloc(*returnColumnSizes, capacity * sizeof(int));
                    }
                    result[*returnSize] = (int*)malloc(4 * sizeof(int));
                    result[*returnSize][0] = nums[i];
                    result[*returnSize][1] = nums[j];
                    result[*returnSize][2] = nums[l];
                    result[*returnSize][3] = nums[r];
                    (*returnColumnSizes)[*returnSize] = 4;
                    (*returnSize)++;
                    while (l < r && nums[l] == nums[l + 1]) l++;
                    while (l < r && nums[r] == nums[r - 1]) r--;
                    l++;
                    r--;
                } else if (sum < target) {
                    l++;
                } else {
                    r--;
                }
            }
        }
    }
    return result;
}

```

# Go

## Sweet Spot

```go
func fourSum(nums []int, target int) [][]int {
    // Time Complexity: O(n^3)
    // Memory Complexity: O(log n)
    res := [][]int{}
    n := len(nums)
    if n < 4 {
        return res
    }
    sort.Ints(nums)
    for i := 0; i < n-3; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        if nums[i]+nums[i+1]+nums[i+2]+nums[i+3] > target {
            break
        }
        if nums[i]+nums[n-3]+nums[n-2]+nums[n-1] < target {
            continue
        }
        for j := i + 1; j < n-2; j++ {
            if j > i+1 && nums[j] == nums[j-1] {
                continue
            }
            if nums[i]+nums[j]+nums[j+1]+nums[j+2] > target {
                break
            }
            if nums[i]+nums[j]+nums[n-2]+nums[n-1] < target {
                continue
            }
            l, r := j+1, n-1
            for l < r {
                sum := nums[i] + nums[j] + nums[l] + nums[r]
                if sum == target {
                    res = append(res, []int{nums[i], nums[j], nums[l], nums[r]})
                    for l < r && nums[l] == nums[l+1] {
                        l++
                    }
                    for l < r && nums[r] == nums[r-1] {
                        r--
                    }
                    l++
                    r--
                } else if sum < target {
                    l++
                } else {
                    r--
                }
            }
        }
    }
    return res
}

```

# Kotlin

## Sweet Spot

```kotlin
class Solution {
    fun fourSum(nums: IntArray, target: Int): List<List<Int>> {
        // Time Complexity: O(n^3)
        // Memory Complexity: O(log n)
        val result = mutableListOf<List<Int>>()
        val n = nums.size
        if (n < 4) return result
        nums.sort()
        for (i in 0 until n - 3) {
            if (i > 0 && nums[i] == nums[i - 1]) continue
            if (nums[i].toLong() + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) break
            if (nums[i].toLong() + nums[n - 3] + nums[n - 2] + nums[n - 1] < target) continue
            for (j in i + 1 until n - 2) {
                if (j > i + 1 && nums[j] == nums[j - 1]) continue
                if (nums[i].toLong() + nums[j] + nums[j + 1] + nums[j + 2] > target) break
                if (nums[i].toLong() + nums[j] + nums[n - 2] + nums[n - 1] < target) continue
                var l = j + 1
                var r = n - 1
                while (l < r) {
                    val sum = nums[i].toLong() + nums[j] + nums[l] + nums[r]
                    if (sum == target.toLong()) {
                        result.add(listOf(nums[i], nums[j], nums[l], nums[r]))
                        while (l < r && nums[l] == nums[l + 1]) l++
                        while (l < r && nums[r] == nums[r - 1]) r--
                        l++
                        r--
                    } else if (sum < target) {
                        l++
                    } else {
                        r--
                    }
                }
            }
        }
        return result
    }
}

```

# swift

## Sweet Spot

```swift
class Solution {
    func fourSum(_ nums: [Int], _ target: Int) -> [[Int]] {
        // Time Complexity: O(n^3)
        // Memory Complexity: O(n)
        let n = nums.count
        guard n >= 4 else { return [] }
        let sortedNums = nums.sorted()
        var result = [[Int]]()
        for i in 0..<n-3 {
            if i > 0 && sortedNums[i] == sortedNums[i-1] { continue }
            if sortedNums[i] + sortedNums[i+1] + sortedNums[i+2] + sortedNums[i+3] > target { break }
            if sortedNums[i] + sortedNums[n-3] + sortedNums[n-2] + sortedNums[n-1] < target { continue }
            for j in i+1..<n-2 {
                if j > i+1 && sortedNums[j] == sortedNums[j-1] { continue }
                if sortedNums[i] + sortedNums[j] + sortedNums[j+1] + sortedNums[j+2] > target { break }
                if sortedNums[i] + sortedNums[j] + sortedNums[n-2] + sortedNums[n-1] < target { continue }
                var l = j + 1
                var r = n - 1
                while l < r {
                    let sum = sortedNums[i] + sortedNums[j] + sortedNums[l] + sortedNums[r]
                    if sum == target {
                        result.append([sortedNums[i], sortedNums[j], sortedNums[l], sortedNums[r]])
                        while l < r && sortedNums[l] == sortedNums[l+1] { l += 1 }
                        while l < r && sortedNums[r] == sortedNums[r-1] { r -= 1 }
                        l += 1
                        r -= 1
                    } else if sum < target {
                        l += 1
                    } else {
                        r -= 1
                    }
                }
            }
        }
        return result
    }
}

```

# rust

## Sweet Spot

```rust
impl Solution {
    pub fn four_sum(mut nums: Vec<i32>, target: i32) -> Vec<Vec<i32>> {
        // Time Complexity: O(n^3)
        // Memory Complexity: O(log n)
        let mut result = Vec::new();
        let n = nums.len();
        if n < 4 { return result; }
        nums.sort_unstable();
        let target = target as i64;
        for i in 0..n - 3 {
            if i > 0 && nums[i] == nums[i - 1] { continue; }
            if (nums[i] as i64 + nums[i+1] as i64 + nums[i+2] as i64 + nums[i+3] as i64) > target { break; }
            if (nums[i] as i64 + nums[n-3] as i64 + nums[n-2] as i64 + nums[n-1] as i64) < target { continue; }
            for j in i + 1..n - 2 {
                if j > i + 1 && nums[j] == nums[j - 1] { continue; }
                if (nums[i] as i64 + nums[j] as i64 + nums[j+1] as i64 + nums[j+2] as i64) > target { break; }
                if (nums[i] as i64 + nums[j] as i64 + nums[n-2] as i64 + nums[n-1] as i64) < target { continue; }
                let (mut l, mut r) = (j + 1, n - 1);
                while l < r {
                    let sum = nums[i] as i64 + nums[j] as i64 + nums[l] as i64 + nums[r] as i64;
                    if sum == target {
                        result.push(vec![nums[i], nums[j], nums[l], nums[r]]);
                        while l < r && nums[l] == nums[l + 1] { l += 1; }
                        while l < r && nums[r] == nums[r - 1] { r -= 1; }
                        l += 1;
                        r -= 1;
                    } else if sum < target {
                        l += 1;
                    } else {
                        r -= 1;
                    }
                }
            }
        }
        result
    }
}

```

# ruby

## Sweet Spot

```ruby
# @param {Integer[]} nums
# @param {Integer} target
# @return {Integer[][]}
def four_sum(nums, target)
    # Time Complexity: O(n^3)
    # Memory Complexity: O(n)
    n = nums.length
    return [] if n < 4
    nums.sort!
    res = []
    (0...n-3).each do |i|
        next if i > 0 && nums[i] == nums[i-1]
        break if nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target
        next if nums[i] + nums[n-3] + nums[n-2] + nums[n-1] < target
        (i+1...n-2).each do |j|
            next if j > i+1 && nums[j] == nums[j-1]
            break if nums[i] + nums[j] + nums[j+1] + nums[j+2] > target
            next if nums[i] + nums[j] + nums[n-2] + nums[n-1] < target
            l, r = j + 1, n - 1
            while l < r
                sum = nums[i] + nums[j] + nums[l] + nums[r]
                if sum == target
                    res << [nums[i], nums[j], nums[l], nums[r]]
                    l += 1 while l < r && nums[l] == nums[l+1]
                    r -= 1 while l < r && nums[r] == nums[r-1]
                    l += 1
                    r -= 1
                elsif sum < target
                    l += 1
                else
                    r -= 1
                end
            end
        end
    end
    res
end

```

# php

## Sweet Spot

```php
class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $target
     * @return Integer[][]
     */
    function fourSum($nums, $target) {
        // Time Complexity: O(n^3)
        // Memory Complexity: O(n)
        $n = count($nums);
        if ($n < 4) return [];
        sort($nums);
        $result = [];
        for ($i = 0; $i < $n - 3; $i++) {
            if ($i > 0 && $nums[$i] == $nums[$i - 1]) continue;
            if ($nums[$i] + $nums[$i + 1] + $nums[$i + 2] + $nums[$i + 3] > $target) break;
            if ($nums[$i] + $nums[$n - 3] + $nums[$n - 2] + $nums[$n - 1] < $target) continue;
            for ($j = $i + 1; $j < $n - 2; $j++) {
                if ($j > $i + 1 && $nums[$j] == $nums[$j - 1]) continue;
                if ($nums[$i] + $nums[$j] + $nums[$j + 1] + $nums[$j + 2] > $target) break;
                if ($nums[$i] + $nums[$j] + $nums[$n - 2] + $nums[$n - 1] < $target) continue;
                $l = $j + 1;
                $r = $n - 1;
                while ($l < $r) {
                    $sum = $nums[$i] + $nums[$j] + $nums[$l] + $nums[$r];
                    if ($sum == $target) {
                        $result[] = [$nums[$i], $nums[$j], $nums[$l], $nums[$r]];
                        while ($l < $r && $nums[$l] == $nums[$l + 1]) $l++;
                        while ($l < $r && $nums[$r] == $nums[$r - 1]) $r--;
                        $l++;
                        $r--;
                    } elseif ($sum < $target) {
                        $l++;
                    } else {
                        $r--;
                    }
                }
            }
        }
        return $result;
    }
}
```

# dart

## Sweet Spot

```dart
class Solution {
  List<List<int>> fourSum(List<int> nums, int target) {
    // Time Complexity: O(n^3)
    // Memory Complexity: O(log n)
    int n = nums.length;
    if (n < 4) return [];
    nums.sort();
    List<List<int>> result = [];
    for (int i = 0; i < n - 3; i++) {
      if (i > 0 && nums[i] == nums[i - 1]) continue;
      if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) break;
      if (nums[i] + nums[n - 3] + nums[n - 2] + nums[n - 1] < target) continue;
      for (int j = i + 1; j < n - 2; j++) {
        if (j > i + 1 && nums[j] == nums[j - 1]) continue;
        if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) break;
        if (nums[i] + nums[j] + nums[n - 2] + nums[n - 1] < target) continue;
        int l = j + 1;
        int r = n - 1;
        while (l < r) {
          int sum = nums[i] + nums[j] + nums[l] + nums[r];
          if (sum == target) {
            result.add([nums[i], nums[j], nums[l], nums[r]]);
            while (l < r && nums[l] == nums[l + 1]) l++;
            while (l < r && nums[r] == nums[r - 1]) r--;
            l++;
            r--;
          } else if (sum < target) {
            l++;
          } else {
            r--;
          }
        }
      }
    }
    return result;
  }
}

```

# scala 3.3.1

## Sweet Spot

```scala 3.3.1
object Solution {
    def fourSum(nums: Array[Int], target: Int): List[List[Int]] = {
        // Time Complexity: O(n^3)
        // Memory Complexity: O(n)
        val n = nums.length
        if (n < 4) return Nil
        val sorted = nums.sorted
        var result = List.empty[List[Int]]
        for (i <- 0 until n - 3) {
            if (i == 0 || sorted(i) != sorted(i - 1)) {
                val t1 = target.toLong - sorted(i)
                for (j <- i + 1 until n - 2) {
                    if (j == i + 1 || sorted(j) != sorted(j - 1)) {
                        val t2 = t1 - sorted(j)
                        var l = j + 1
                        var r = n - 1
                        while (l < r) {
                            val sum = sorted(l).toLong + sorted(r)
                            if (sum == t2) {
                                result = List(sorted(i), sorted(j), sorted(l), sorted(r)) :: result
                                while (l < r && sorted(l) == sorted(l + 1)) l += 1
                                while (l < r && sorted(r) == sorted(r - 1)) r -= 1
                                l += 1
                                r -= 1
                            } else if (sum < t2) {
                                l += 1
                            } else {
                                r -= 1
                            }
                        }
                    }
                }
            }
        }
        result
    }
}

```

# Elixir 1.17 with Erlang/OTP 26

## Sweet Spot

```elixir 1.17 with Erlang/OTP 26
defmodule Solution do
  @spec four_sum(nums :: [integer], target :: integer) :: [[integer]]
  def four_sum(nums, target) do
    # Time Complexity: O(n^3)
    # Memory Complexity: O(n)
    sorted = Enum.sort(nums)
    len = length(sorted)
    if len < 4 do
      []
    else
      vec = List.to_tuple(sorted)
      find_quads(vec, len, target)
    end
  end

  defp find_quads(vec, n, target) do
    for i <- 0..(n - 4),
        i == 0 or elem(vec, i) != elem(vec, i - 1),
        j <- (i + 1)..(n - 3),
        j == i + 1 or elem(vec, j) != elem(vec, j - 1),
        reduce: [] do
      acc ->
        two_sum(vec, j + 1, n - 1, target - elem(vec, i) - elem(vec, j), elem(vec, i), elem(vec, j), acc)
    end
  end

  defp two_sum(vec, l, r, t, v1, v2, acc) when l < r do
    sum = elem(vec, l) + elem(vec, r)
    cond do
      sum == t ->
        new_acc = [[v1, v2, elem(vec, l), elem(vec, r)] | acc]
        two_sum(vec, skip_left(vec, l, r), skip_right(vec, l, r), t, v1, v2, new_acc)
      sum < t ->
        two_sum(vec, l + 1, r, t, v1, v2, acc)
      true ->
        two_sum(vec, l, r - 1, t, v1, v2, acc)
    end
  end
  defp two_sum(_, _, _, _, _, _, acc), do: acc

  defp skip_left(vec, l, r) when l < r and elem(vec, l) == elem(vec, l + 1), do: skip_left(vec, l + 1, r)
  defp skip_left(_, l, _), do: l + 1

  defp skip_right(vec, l, r) when l < r and elem(vec, r) == elem(vec, r - 1), do: skip_right(vec, l, r - 1)
  defp skip_right(_, _, r), do: r - 1
end

```

# Erlang/OTP 26

## Sweet Spot

```erlang/otp 26
-spec four_sum(Nums :: [integer()], Target :: integer()) -> [[integer()]].
four_sum(Nums, Target) ->
  % Time Complexity: O(n^3)
  % Memory Complexity: O(n)
  Sorted = lists:sort(Nums),
  Len = length(Sorted),
  if Len < 4 -> [];
     true ->
       Vec = list_to_tuple(Sorted),
       find_quads(Vec, Len, Target)
  end.

find_quads(Vec, N, Target) ->
  lists:foldl(fun(I, AccI) ->
    IdxI = I - 1,
    if (IdxI == 0) orelse (element(I, Vec) /= element(IdxI, Vec)) ->
      lists:foldl(fun(J, AccJ) ->
        IdxJ = J - 1,
        if (J == I + 1) orelse (element(J, Vec) /= element(IdxJ, Vec)) ->
          two_sum(Vec, J + 1, N, Target - element(I, Vec) - element(J, Vec), element(I, Vec), element(J, Vec), AccJ);
        true -> AccJ
        end
      end, AccI, lists:seq(I + 1, N - 2));
    true -> AccI
    end
  end, [], lists:seq(1, N - 3)).

two_sum(Vec, L, R, T, V1, V2, Acc) when L < R ->
  Sum = element(L, Vec) + element(R, Vec),
  if Sum == T ->
       NewAcc = [[V1, V2, element(L, Vec), element(R, Vec)] | Acc],
       two_sum(Vec, skip_left(Vec, L, R), skip_right(Vec, L, R), T, V1, V2, NewAcc);
     Sum < T -> two_sum(Vec, L + 1, R, T, V1, V2, Acc);
     true -> two_sum(Vec, L, R - 1, T, V1, V2, Acc)
  end;
two_sum(_, _, _, _, _, _, Acc) -> Acc.

skip_left(Vec, L, R) ->
  if (L < R) andalso (element(L, Vec) == element(L + 1, Vec)) -> skip_left(Vec, L + 1, R);
     true -> L + 1
  end.

skip_right(Vec, L, R) ->
  if (L < R) andalso (element(R, Vec) == element(R - 1, Vec)) -> skip_right(Vec, L, R - 1);
     true -> R - 1
  end.

```

# Racket CS v8.15

## Sweet Spot

```racket CS v8.15
(define/contract (four-sum nums target)
  (-> (listof exact-integer?) exact-integer? (listof (listof exact-integer?)))
  ; Time Complexity: O(n^3)
  ; Memory Complexity: O(n)
  (let* ([sorted (sort nums <)]
         [vec (list->vector sorted)]
         [n (vector-length vec)])
    (if (< n 4)
        '()
        (let ([res '()])
          (for ([i (in-range 0 (- n 3))])
            (when (or (= i 0) (not (= (vector-ref vec i) (vector-ref vec (- i 1)))))
              (for ([j (in-range (+ i 1) (- n 2))])
                (when (or (= j (+ i 1)) (not (= (vector-ref vec j) (vector-ref vec (- j 1)))))
                  (let loop ([l (+ j 1)] [r (- n 1)])
                    (when (< l r)
                      (let ([sum (+ (vector-ref vec i) (vector-ref vec j) (vector-ref vec l) (vector-ref vec r))])
                        (cond
                          [(= sum target)
                           (set! res (cons (list (vector-ref vec i) (vector-ref vec j) (vector-ref vec l) (vector-ref vec r)) res))
                           (let skip ([nl l] [nr r])
                             (cond
                               [(and (< nl nr) (= (vector-ref vec nl) (vector-ref vec (+ nl 1))))
                                (skip (+ nl 1) nr)]
                               [(and (< nl nr) (= (vector-ref vec nr) (vector-ref vec (- nr 1))))
                                (skip nl (- nr 1))]
                               [else (loop (+ nl 1) (- nr 1))]))]
                          [(< sum target) (loop (+ l 1) r)]
                          [else (loop l (- r 1))]))))))))
          res))))
```