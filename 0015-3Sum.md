# cpp

## Sweet Spot

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        vector<vector<int>> result;
        for (int i = 0; i < n - 2; ++i) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            int target = -nums[i];
            int left = i + 1, right = n - 1;
            while (left < right) {
                int sum = nums[left] + nums[right];
                if (sum == target) {
                    result.push_back({nums[i], nums[left], nums[right]});
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    left++;
                    right--;
                } else if (sum < target) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        return result;
    }
};
// Time: O(n^2), Memory: O(log n) to O(n) depending on sort

```

# java

## Sweet Spot

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int n = nums.length;
        Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();
        for (int i = 0; i < n - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            int left = i + 1, right = n - 1;
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum == 0) {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    left++;
                    right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        return result;
    }
}
// Time: O(n^2), Memory: O(log n)

```

# python 3.14

## Sweet Spot

```python 3.14
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = []
        n = len(nums)
        for i in range(n - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            l, r = i + 1, n - 1
            while l < r:
                s = nums[i] + nums[l] + nums[r]
                if s < 0:
                    l += 1
                elif s > 0:
                    r -= 1
                else:
                    res.append([nums[i], nums[l], nums[r]])
                    while l < r and nums[l] == nums[l + 1]:
                        l += 1
                    while l < r and nums[r] == nums[r - 1]:
                        r -= 1
                    l += 1
                    r -= 1
        return res
# Time: O(n^2), Memory: O(n)

```

# python 2.7.11

## Sweet Spot

```python 2.7.11
class Solution(object):
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        nums.sort()
        res = []
        n = len(nums)
        for i in range(n - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            l, r = i + 1, n - 1
            while l < r:
                s = nums[i] + nums[l] + nums[r]
                if s < 0:
                    l += 1
                elif s > 0:
                    r -= 1
                else:
                    res.append([nums[i], nums[l], nums[r]])
                    while l < r and nums[l] == nums[l + 1]:
                        l += 1
                    while l < r and nums[r] == nums[r - 1]:
                        r -= 1
                    l += 1
                    r -= 1
        return res
# Time: O(n^2), Memory: O(n)

```

# JavaScript

## Sweet Spot

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
    nums.sort((a, b) => a - b);
    const result = [];
    for (let i = 0; i < nums.length - 2; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) continue;
        let left = i + 1, right = nums.length - 1;
        while (left < right) {
            const sum = nums[i] + nums[left] + nums[right];
            if (sum === 0) {
                result.push([nums[i], nums[left], nums[right]]);
                while (nums[left] === nums[left + 1]) left++;
                while (nums[right] === nums[right - 1]) right--;
                left++;
                right--;
            } else if (sum < 0) {
                left++;
            } else {
                right--;
            }
        }
    }
    return result;
};
// Time: O(n^2), Memory: O(log n)

```

# Typescript

## Sweet Spot

```typescript
function threeSum(nums: number[]): number[][] {
    nums.sort((a, b) => a - b);
    const result: number[][] = [];
    for (let i = 0; i < nums.length - 2; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) continue;
        let left = i + 1, right = nums.length - 1;
        while (left < right) {
            const sum = nums[i] + nums[left] + nums[right];
            if (sum === 0) {
                result.push([nums[i], nums[left], nums[right]]);
                while (left < right && nums[left] === nums[left + 1]) left++;
                while (left < right && nums[right] === nums[right - 1]) right--;
                left++;
                right--;
            } else if (sum < 0) {
                left++;
            } else {
                right--;
            }
        }
    }
    return result;
};
// Time: O(n^2), Memory: O(log n)

```

# C#

## Sweet Spot

```c#
public class Solution {
    public IList<IList<int>> ThreeSum(int[] nums) {
        Array.Sort(nums);
        var result = new List<IList<int>>();
        for (int i = 0; i < nums.Length - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            int left = i + 1, right = nums.Length - 1;
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum == 0) {
                    result.Add(new List<int> { nums[i], nums[left], nums[right] });
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    left++;
                    right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        return result;
    }
}
// Time: O(n^2), Memory: O(log n)

```

# C

## Sweet Spot

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int compare(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}

int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {
    qsort(nums, numsSize, sizeof(int), compare);
    int capacity = 1024;
    int** res = (int**)malloc(capacity * sizeof(int*));
    *returnColumnSizes = (int*)malloc(capacity * sizeof(int));
    *returnSize = 0;

    for (int i = 0; i < numsSize - 2; i++) {
        if (i > 0 && nums[i] == nums[i - 1]) continue;
        int l = i + 1, r = numsSize - 1;
        while (l < r) {
            int sum = nums[i] + nums[l] + nums[r];
            if (sum == 0) {
                if (*returnSize >= capacity) {
                    capacity *= 2;
                    res = (int**)realloc(res, capacity * sizeof(int*));
                    *returnColumnSizes = (int*)realloc(*returnColumnSizes, capacity * sizeof(int));
                }
                res[*returnSize] = (int*)malloc(3 * sizeof(int));
                res[*returnSize][0] = nums[i];
                res[*returnSize][1] = nums[l];
                res[*returnSize][2] = nums[r];
                (*returnColumnSizes)[*returnSize] = 3;
                (*returnSize)++;
                while (l < r && nums[l] == nums[l + 1]) l++;
                while (l < r && nums[r] == nums[r - 1]) r--;
                l++; r--;
            } else if (sum < 0) l++;
            else r--;
        }
    }
    return res;
}
// Time: O(n^2), Memory: O(log n)

```

# Go

## Sweet Spot

```go
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    res := [][]int{}
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        l, r := i+1, len(nums)-1
        for l < r {
            sum := nums[i] + nums[l] + nums[r]
            if sum == 0 {
                res = append(res, []int{nums[i], nums[l], nums[r]})
                for l < r && nums[l] == nums[l+1] {
                    l++
                }
                for l < r && nums[r] == nums[r-1] {
                    r--
                }
                l++
                r--
            } else if sum < 0 {
                l++
            } else {
                r--
            }
        }
    }
    return res
}
// Time: O(n^2), Memory: O(log n)

```

# Kotlin

## Sweet Spot

```kotlin
class Solution {
    fun threeSum(nums: IntArray): List<List<Int>> {
        nums.sort()
        val result = mutableListOf<List<Int>>()
        for (i in 0 until nums.size - 2) {
            if (i > 0 && nums[i] == nums[i - 1]) continue
            var l = i + 1
            var r = nums.size - 1
            while (l < r) {
                val sum = nums[i] + nums[l] + nums[r]
                when {
                    sum == 0 -> {
                        result.add(listOf(nums[i], nums[l], nums[r]))
                        while (l < r && nums[l] == nums[l + 1]) l++
                        while (l < r && nums[r] == nums[r - 1]) r--
                        l++
                        r--
                    }
                    sum < 0 -> l++
                    else -> r--
                }
            }
        }
        return result
    }
}
// Time: O(n^2), Memory: O(log n)

```

# swift

## Sweet Spot

```swift
class Solution {
    func threeSum(_ nums: [Int]) -> [[Int]] {
        let sorted = nums.sorted()
        var result = [[Int]]()
        let n = sorted.count
        if n < 3 { return [] }
        for i in 0..<n-2 {
            if i > 0 && sorted[i] == sorted[i-1] { continue }
            var l = i + 1
            var r = n - 1
            while l < r {
                let sum = sorted[i] + sorted[l] + sorted[r]
                if sum == 0 {
                    result.append([sorted[i], sorted[l], sorted[r]])
                    while l < r && sorted[l] == sorted[l+1] { l += 1 }
                    while l < r && sorted[r] == sorted[r-1] { r -= 1 }
                    l += 1
                    r -= 1
                } else if sum < 0 {
                    l += 1
                } else {
                    r -= 1
                }
            }
        }
        return result
    }
}
// Time: O(n^2), Memory: O(n)

```

# rust

## Sweet Spot

```rust
impl Solution {
    pub fn three_sum(mut nums: Vec<i32>) -> Vec<Vec<i32>> {
        nums.sort();
        let mut res = Vec::new();
        let n = nums.len();
        if n < 3 { return res; }
        for i in 0..n - 2 {
            if i > 0 && nums[i] == nums[i - 1] { continue; }
            let mut l = i + 1;
            let mut r = n - 1;
            while l < r {
                let sum = nums[i] + nums[l] + nums[r];
                if sum == 0 {
                    res.push(vec![nums[i], nums[l], nums[r]]);
                    while l < r && nums[l] == nums[l + 1] { l += 1; }
                    while l < r && nums[r] == nums[r - 1] { r -= 1; }
                    l += 1;
                    r -= 1;
                } else if sum < 0 {
                    l += 1;
                } else {
                    r -= 1;
                }
            }
        }
        res
    }
}
// Time: O(n^2), Memory: O(log n)

```

# ruby

## Sweet Spot

```ruby
# @param {Integer[]} nums
# @return {Integer[][]}
def three_sum(nums)
    nums.sort!
    res = []
    (0...nums.length - 2).each do |i|
        next if i > 0 && nums[i] == nums[i-1]
        l, r = i + 1, nums.length - 1
        while l < r
            sum = nums[i] + nums[l] + nums[r]
            if sum == 0
                res << [nums[i], nums[l], nums[r]]
                l += 1 while l < r && nums[l] == nums[l+1]
                r -= 1 while l < r && nums[r] == nums[r-1]
                l += 1
                r -= 1
            elsif sum < 0
                l += 1
            else
                r -= 1
            end
        end
    end
    res
end
# Time: O(n^2), Memory: O(log n)

```

# php

## Sweet Spot

```php
class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer[][]
     */
    function threeSum($nums) {
        sort($nums);
        $res = [];
        $n = count($nums);
        for ($i = 0; $i < $n - 2; $i++) {
            if ($i > 0 && $nums[$i] == $nums[$i - 1]) continue;
            $l = $i + 1;
            $r = $n - 1;
            while ($l < $r) {
                $sum = $nums[$i] + $nums[$l] + $nums[$r];
                if ($sum == 0) {
                    $res[] = [$nums[$i], $nums[$l], $nums[$r]];
                    while ($l < $r && $nums[$l] == $nums[$l + 1]) $l++;
                    while ($l < $r && $nums[$r] == $nums[$r - 1]) $r--;
                    $l++;
                    $r--;
                } elseif ($sum < 0) {
                    $l++;
                } else {
                    $r--;
                }
            }
        }
        return $res;
    }
}
// Time: O(n^2), Memory: O(log n)

```

# dart

## Sweet Spot

```dart
class Solution {
  List<List<int>> threeSum(List<int> nums) {
    nums.sort();
    List<List<int>> res = [];
    int n = nums.length;
    for (int i = 0; i < n - 2; i++) {
      if (i > 0 && nums[i] == nums[i - 1]) continue;
      int l = i + 1;
      int r = n - 1;
      while (l < r) {
        int sum = nums[i] + nums[l] + nums[r];
        if (sum == 0) {
          res.add([nums[i], nums[l], nums[r]]);
          while (l < r && nums[l] == nums[l + 1]) l++;
          while (l < r && nums[r] == nums[r - 1]) r--;
          l++;
          r--;
        } else if (sum < 0) {
          l++;
        } else {
          r--;
        }
      }
    }
    return res;
  }
}
// Time: O(n^2), Memory: O(log n)

```

# scala 3.3.1

## Sweet Spot

```scala 3.3.1
object Solution {
    def threeSum(nums: Array[Int]): List[List[Int]] = {
        val sorted = nums.sorted
        val res = scala.collection.mutable.ListBuffer[List[Int]]()
        val n = sorted.length
        for (i <- 0 until n - 2) {
            if (i == 0 || sorted(i) != sorted(i - 1)) {
                var l = i + 1
                var r = n - 1
                while (l < r) {
                    val sum = sorted(i) + sorted(l) + sorted(r)
                    if (sum == 0) {
                        res += List(sorted(i), sorted(l), sorted(r))
                        while (l < r && sorted(l) == sorted(l + 1)) l += 1
                        while (l < r && sorted(r) == sorted(r - 1)) r -= 1
                        l += 1
                        r -= 1
                    } else if (sum < 0) {
                        l += 1
                    } else {
                        r -= 1
                    }
                }
            }
        }
        res.toList
    }
}
// Time: O(n^2), Memory: O(n)

```

# Elixir 1.17 with Erlang/OTP 26

## Sweet Spot

```elixir 1.17 with Erlang/OTP 26
defmodule Solution do
  @spec three_sum(nums :: [integer]) :: [[integer]]
  def three_sum(nums) do
    sorted = Enum.sort(nums)
    tuple = List.to_tuple(sorted)
    n = tuple_size(tuple)
    if n < 3 do
      []
    else
      find_triplets(tuple, 0, n, [])
    end
  end

  defp find_triplets(t, i, n, acc) when i > n - 3, do: acc
  defp find_triplets(t, i, n, acc) do
    if i > 0 and elem(t, i) == elem(t, i - 1) do
      find_triplets(t, i + 1, n, acc)
    else
      new_acc = two_sum(t, i + 1, n - 1, -elem(t, i), elem(t, i), acc)
      find_triplets(t, i + 1, n, new_acc)
    end
  end

  defp two_sum(_, l, r, _, _, acc) when l >= r, do: acc
  defp two_sum(t, l, r, target, first, acc) do
    sum = elem(t, l) + elem(t, r)
    cond do
      sum == target ->
        new_acc = [[first, elem(t, l), elem(t, r)] | acc]
        {nl, nr} = skip_duplicates(t, l, r)
        two_sum(t, nl + 1, nr - 1, target, first, new_acc)
      sum < target ->
        two_sum(t, l + 1, r, target, first, acc)
      true ->
        two_sum(t, l, r - 1, target, first, acc)
    end
  end

  defp skip_duplicates(t, l, r) do
    nl = if l < r and elem(t, l) == elem(t, l + 1), do: skip_l(t, l, r), else: l
    nr = if l < r and elem(t, r) == elem(t, r - 1), do: skip_r(t, l, r), else: r
    {nl, nr}
  end

  defp skip_l(t, l, r) when l < r and elem(t, l) == elem(t, l + 1), do: skip_l(t, l + 1, r)
  defp skip_l(_, l, _), do: l

  defp skip_r(t, l, r) when l < r and elem(t, r) == elem(t, r - 1), do: skip_r(t, l, r - 1)
  defp skip_r(_, _, r), do: r
end
# Time: O(n^2), Memory: O(n)

```

# Erlang/OTP 26

## Sweet Spot

```erlang/otp 26
-spec three_sum(Nums :: [integer()]) -> [[integer()]].
three_sum(Nums) ->
    Sorted = lists:sort(Nums),
    Tuple = list_to_tuple(Sorted),
    N = tuple_size(Tuple),
    find_triplets(Tuple, 1, N, []).

find_triplets(T, I, N, Acc) when I > N - 2 -> Acc;
find_triplets(T, I, N, Acc) ->
    Val = element(I, T),
    if I > 1, Val == element(I - 1, T) ->
        find_triplets(T, I + 1, N, Acc);
    true ->
        NewAcc = two_sum(T, I + 1, N, -Val, Val, Acc),
        find_triplets(T, I + 1, N, NewAcc)
    end.

two_sum(T, L, R, Target, First, Acc) when L >= R -> Acc;
two_sum(T, L, R, Target, First, Acc) ->
    Sum = element(L, T) + element(R, T),
    if Sum == Target ->
        NewAcc = [[First, element(L, T), element(R, T)] | Acc],
        {NL, NR} = skip_dup(T, L, R),
        two_sum(T, NL + 1, NR - 1, Target, First, NewAcc);
    Sum < Target ->
        two_sum(T, L + 1, R, Target, First, Acc);
    true ->
        two_sum(T, L, R - 1, Target, First, Acc)
    end.

skip_dup(T, L, R) ->
    NL = skip_l(T, L, R),
    NR = skip_r(T, L, R),
    {NL, NR}.

skip_l(T, L, R) when L < R, element(L, T) == element(L + 1, T) -> skip_l(T, L + 1, r);
skip_l(_, L, _) -> L.

skip_r(T, L, R) when L < R, element(R, T) == element(R - 1, T) -> skip_r(T, L, R - 1);
skip_r(_, _, R) -> R.
% Time: O(n^2), Memory: O(n)

```

# Racket CS v8.15

## Sweet Spot

```racket CS v8.15
(define/contract (three-sum nums)
  (-> (listof exact-integer?) (listof (listof exact-integer?)))
  (let* ([sorted-nums (sort nums <)]
         [vec (list->vector sorted-nums)]
         [n (vector-length vec)]
         [res '()])
    (for ([i (in-range 0 (- n 2))])
      (when (or (= i 0) (not (= (vector-ref vec i) (vector-ref vec (- i 1)))))
        (let loop ([l (+ i 1)] [r (- n 1)])
          (when (< l r)
            (let* ([v-i (vector-ref vec i)]
                   [v-l (vector-ref vec l)]
                   [v-r (vector-ref vec r)]
                   [sum (+ v-i v-l v-r)])
              (cond
                [(= sum 0)
                 (set! res (cons (list v-i v-l v-r) res))
                 (let skip-l ([nl l])
                   (if (and (< nl r) (= (vector-ref vec nl) (vector-ref vec (+ nl 1))))
                       (skip-l (+ nl 1))
                       (let skip-r ([nr r])
                         (if (and (> nr nl) (= (vector-ref vec nr) (vector-ref vec (- nr 1))))
                             (skip-r (- nr 1))
                             (loop (+ skip-l-res 1) (- skip-r-res 1))))))] ; Abstracted logic for readability
                [(< sum 0) (loop (+ l 1) r)]
                [else (loop l (- r 1))]))))))
    res))
; Time: O(n^2), Memory: O(n)

```